link: https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/

因为我以前学过一点KMP，但忘光了，所以重新学，且学的过程中把思路记下来。
KMP，在一个字符串找另一个子串的过程。暴力做法两层for，从头开始比。
有一个想法是，如果能在匹配失败的时候，知道失败处的前几个字符是匹配成功的，子串就不用从头开始比较了。
精髓就是，在某个位置匹配失败后，找当前子串的从前往后，和从后往前，相同的部分（要匹配的子串为abcdabcf，f失败，发现前后都有abc，从d新开始），然后让子串指针移到从前往后串的后一个，主串指针不动（还在比较失败的位置），然后继续比较。
aabaabaafa 中找 aabaaf的位置（3）。
aabaaf
   aabaaf
当发现b和f匹配失败的时候，可不可以让主串的指针不动，且不让子串aabaaf的指针回到起点a，而是回到子串的一个中间位置.
所以我要找，子串从头开始往后的某一部分（a串），或者从匹配失败点往前的某一部分（b串），这两个部分，有没有存在相同（a和b串相同），且也和主串从后往前的某一部分（c串）相同（a=b=c）。
子串从后（f）往前的一部分串b（aa），是确定能和主串从后（b）往前的串c（aa）匹配上的。
这时，如果子串从前往后也有一个串a（aa）和上面说的那俩串相同，就可以确定子串前面的串a一定和主串匹配失败前面的串c匹配上。
那就可以从这个子串a（aa）的后一个元素开始，和主串的匹配失败位置串c后面（b）比较，不用两个都回头部重新来。
简单来说，就是找子串aabaaf的前后（a和b串）有无相同部分。如果有，让子串的指针指向前面相同部分（a串=aa）的后一个元素（b），和主串不动的指针开始一起往后比。
相当于把子串向后移动到和主串上下重合的某个位置，这个位置的起点就是a串的头和c串的头上下对齐。也就等同于主串指针不动，子串指针移到a串后面。b和c一定相同，所以关键是找a和b。
a串就叫前缀，带头不带尾；b串就叫后缀，不带头带尾。我们找的是相同的前后缀中（满足a=b），长度最长的。
aabaa，前缀是a,aa,aab,aaba  后缀是 abaa,baa,aa,a。 这样a和b相同为aa和a，而最长长度就是2（aa），所以接下来子串指针跳过前缀（两个元素），正好从下标2开始。
为了记录前后缀（最长相同前后缀长度），我们维护一个前缀表（数组实现）。aabaaf子串，数组长度就是6，每个位置的元素，表示从头开始到他这个元素形成的串，的最长相同前后缀的长度。
（arr[4]=2,表示从头a开始，到当前下标4的元素a，形成的串aabaa，的最长相同前后缀长度）。
这样我们在发现aabaaf的f匹配不上，就去找f的前一个元素（a）下标（4）的前缀表值，是2，所以指针跳到2（b），再和主串的指针开始往后比较。
这就是思路！

然后是前缀表next[]怎么求。我想一一对应，不搞-1。


关于指针回溯求next的理解
每次求next【i】，可看作前缀与后缀的一次匹配，在该过程中就可以用上之前所求的next，若匹配失败，则像模式串与父串匹配一样，将指针移到next【j-1】上。
求next过程实际上是dp（动态规划），只与前一个状态有关：
若不匹配，一直往前退到0或匹配为止
若匹配，则将之前的结果传递：
因为之前的结果不为0时，前后缀有相等的部分，所以j所指的实际是与当前值相等的前缀，可视为将前缀从前面拖了过来，就不必将指针从前缀开始匹配了，所以之前的结果是可以传递的。

求next数组的时候就是在用kmp，把 【0,j】 的前缀看成是模式串，把 【1,i】 的后缀看成是文本串
①文本串一直是每次循环+1，不会回退。
②模式串有时候可以通过next数组跳过前面几个字符直接比较，这两点就是kmp高效的地方。


最后是整体代码！！

class Solution {
    //前缀表（不减一）Java实现
    public int strStr(String haystack, String needle) {
        if (needle.length() == 0) return 0;
        int[] next = new int[needle.length()];
        getNext(next, needle);

//如果某位置上下（主子元素）不等，下指针(j)根据前缀表(next数组)中当前位置(j)的前一个元素下标的值（next[j-1]），移动到新位置(j = next[j - 1])。
        int j = 0;
        for (int i = 0; i < haystack.length(); i++) {
            while (j > 0 && needle.charAt(j) != haystack.charAt(i)) 
                j = next[j - 1];
            if (needle.charAt(j) == haystack.charAt(i)) 
                j++;
            if (j == needle.length()) 
                return i - needle.length() + 1;
        }
        return -1;

    }

    //求前缀表
    private void getNext(int[] next, String s) {
        int j = 0;
        next[0] = 0;
        for (int i = 1; i < s.length(); i++) {
            while (j > 0 && s.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (s.charAt(j) == s.charAt(i)) {
                j++;
            }
            next[i] = j; 
        }
    }
}













