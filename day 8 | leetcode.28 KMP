link: https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/

因为我以前学过一点KMP，但忘光了，所以重新学，且学的过程中把思路记下来。
KMP，在一个字符串找另一个子串的过程。暴力做法两层for，从头开始比。
有一个想法是，如果能在匹配失败的时候，知道失败处的前几个字符是匹配成功的，子串就不用从头开始比较了。
精髓就是，在某个位置匹配失败后，找当前子串的从前往后，和从后往前，相同的部分（要匹配的子串为abcdabcf，f失败，发现前后都有abc，从d新开始），然后让子串指针移到从前往后串的后一个，主串指针不动（还在比较失败的位置），然后继续比较。
aabaabaafa 中找 aabaaf的位置（3）。
aabaaf
   aabaaf
当发现b和f匹配失败的时候，可不可以让主串的指针不动，且不让子串aabaaf的指针回到起点a，而是回到子串的一个中间位置.
所以我要找，子串从头开始往后的某一部分（a串），或者从匹配失败点往前的某一部分（b串），这两个部分，有没有存在相同（a和b串相同），且也和主串从后往前的某一部分（c串）相同（a=b=c）。
子串从后（f）往前的一部分串b（aa），是确定能和主串从后（b）往前的串c（aa）匹配上的。
这时，如果子串从前往后也有一个串a（aa）和上面说的那俩串相同，就可以确定子串前面的串a一定和主串匹配失败前面的串c匹配上。
那就可以从这个子串a（aa）的后一个元素开始，和主串的匹配失败位置串c后面（b）比较，不用两个都回头部重新来。
简单来说，就是找子串aabaaf的前后（a和b串）有无相同部分。如果有，让子串的指针指向前面相同部分（a串=aa）的后一个元素（b），和主串不动的指针开始一起往后比。
相当于把子串向后移动到和主串上下重合的某个位置，这个位置的起点就是a串的头和c串的头上下对齐。也就等同于主串指针不动，子串指针移到a串后面。









