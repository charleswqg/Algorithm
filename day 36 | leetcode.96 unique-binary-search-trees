link: https://leetcode.cn/problems/unique-binary-search-trees/description/
这道题也没想出来！！递推公式想不到，两个元素组成的二叉搜索树，不管这两个元素是谁，布局上看就只有两种，这是关键。
五步曲，dp数组表示n个节点（元素，也想当于值从1到n）组成的二叉搜索树有多少种。
递推公式，当前总共i个元素时，以从1到i的每个元素作为根节点，左子树有j-1个元素（1到j-1），右子树有i-j个元素（j+1到i）。

！！！！比如i=10，j循环到5时，左4个右5个。这右5个元素是6，7，8，9和10。关键来了！虽然值不同，但在布局上看，678910和1，2，3，4，5这五个元素所能组成的布局是一样的！！
所以可以用dp【5】（dp[i-j]）表示678910这5个元素所能组成的二叉搜索树种类的个数！！！！！
！！！！还有一点，dp【2-1=1】，表示i=2（1，2两个元素，也代表总共两个节点），以1为根节点，左子树有2-1=1个元素，这个元素的值也是1.所以其实可以直接按照节点的个数想，不用去纠结数值是多少，因为只要个数相同，布局就会相同。

初始化0个元素的情况下，算1种可能，因为不能算0种，乘完就没了。
遍历顺序从前往后，因为dp【10】（把10个节点按根节点相对大小拆分为左右子树时）需要dp【10之前】的值作为确定内层循环某个跟节点j后，他的左右子树的种类，的个数。然后想乘，作为当前j的种类。
然后把每个j的种类相加，作为当前i的总二叉搜索树种类。（dp[i]+=每个j的种类）
然后写码举例实现。

class Solution {
    public int numTrees(int n) {
        //初始化 dp 数组
        int[] dp = new int[n + 1];
        //初始化0个节点和1个节点的情况
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                //对于第i个节点，需要考虑1作为根节点直到i作为根节点的情况，所以需要累加（j就是每次当前的根节点）
                //一共i个节点，对于根节点j时,左子树的节点个数为j-1，右子树的节点个数为i-j
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
}
